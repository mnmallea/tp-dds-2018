#Decisiones de diseño

[]Para calcular el monto estimado a pagar de los clientes se uso el patrón strategy ya que cada cliente puede cambiar de categoría dependiendo de su consumo. Esto es porque el calculo para estimar el monto a pagar depende de la categoria. De haber utilizado la herencia, nos hubiéramos atado a que cada cliente fuera una instancia de una de las subclases, impidiendo cambiar de categoría. (Ej: ClienteR1 extends Cliente, este nunca podria pasar a R2).
[]El categorizador lo hicimos como un Singleton. En un momento consideramos que todas las categorias sean atributos del cliente, pero no nos parecio del todo cohesivo porque el cliente tenia mucha responsabilidad. Para eso creamos la abstraccion Categorizador que es el que tiene las categorias y, además, el encargado de categorizar al cliente.
[]Los constructores de Cliente y Administrador sirven tanto para instanciar como para configurar. Ya que al crear un usuario con el constructor tiene todas las dependencias requeridas para ser un objeto consistente. Ademas esto te garantiza que no lo vas a poder cambiar (inmutabilidad), salvo en la categoria del Cliente en la que es necesario hacerlo.
[]Suponemos que todos los dispositivos se instancian apagados. Luego se los puede encender. No modelamos por separado DispositivosInteligentes de DispositivosNormales, porque en esta entrega no hacía falta.
[]Hicimos TipoDocumento como enum para acotar los valores que puede tener el TipoDocumento del Cliente.